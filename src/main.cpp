extern "C" {
#include <stdio.h>
#include <stdint.h>
#include <stdbool.h>
//
#include "app_error.h"
#include "app_timer.h"
#include "app_util.h"
#include "ble.h"
#include "ble_db_discovery.h"
#include "ble_stack_handler_types.h"
#include "ble_gap.h"
#include "ble_hci.h"
#include "boards.h"
#include "bsp.h"
#include "bsp_btn_ble.h"
#include "nordic_common.h"
#include "nrf.h"
#include "nrf52.h"
#include "nrf_drv_gpiote.h"
#include "nrf_nvic.h"
#include "softdevice_handler.h"
//
}

#define NRF_LOG_MODULE_NAME "APP"

extern "C"
{
#include "nrf_log.h"
#include "nrf_log_ctrl.h"
}

#define SCAN_INTERVAL           0x0200                 	 /**< Determines scan interval in units of 0.625 millisecond. */
#define SCAN_WINDOW             0x0050 	 //80x0.625=50ms /**< Determines scan window in units of 0.625 millisecond. */
#define SCAN_TIMEOUT            0x0000                                  /**< Timout when scanning. 0x0000 disables timeout. */
#define SCAN_THRESHOLD			-90	  								//TODO dyn param avec whitelist

/** @brief Parameters used when scanning. */
static ble_gap_scan_params_t const m_scan_params {
	/*.active   =*/1,
	/*.use_whitelist =*/0,
	/*.adv_dir_report =*/1,
	/*.interval = */SCAN_INTERVAL,
	/*.window   = */SCAN_WINDOW,
	/*.timeout  = */SCAN_TIMEOUT };

#ifdef BSP_BUTTON_0
#define IR1_IN BSP_BUTTON_0	//BSP_BUTTON_0=BUTTON_1=13
#endif
#ifndef IR1_IN
#error "Please indicate input pin"
#endif

#ifdef BSP_LED_1				//LED2=18
#define TIMESLOT_OUT BSP_LED_1
#endif
#ifndef TIMESLOT_OUT
#error "Please indicate output pin"
#endif

#ifdef BSP_LED_2				//LED3=19
#define RADIO_OUT BSP_LED_2
#endif
#ifndef RADIO_OUT
#error "Please indicate output pin"
#endif

#ifdef BSP_LED_3				//LED3=19
#define RADIO_NOTIF_OUT BSP_LED_3
#endif
#ifndef RADIO_OUT
#error "Please indicate output pin"
#endif



/**Constants for timeslot API
 */
static nrf_radio_request_t  m_timeslot_request;
static uint32_t             m_slot_length_us;
static nrf_radio_signal_callback_return_param_t signal_callback_return_param;

#define SLOT_LENGTH_US 		  10000
#define SLOT_EXTEND_US 		   1000
#define SLOT_TIMEOUT_US		1000000
#define SLOT_SANITY_END_US 	   1000

/**@snippet [Handling events from the ble_nus_c module] */

/**@brief Function for putting the chip into sleep mode.
 *
 * @note This function will not return.
 */
static void sleep_mode_enter(void) {
	ret_code_t err_code;

	err_code = bsp_indication_set(BSP_INDICATE_IDLE);
	APP_ERROR_CHECK(err_code);

	// Prepare wakeup buttons.
	err_code = bsp_btn_ble_sleep_mode_prepare();
	APP_ERROR_CHECK(err_code);

	// Go to system-off mode (this function will not return; wakeup will cause a reset).
	err_code = sd_power_system_off();
	APP_ERROR_CHECK(err_code);
}

/**@brief Function for handling events from the BSP module.
 *
 * @param[in] event  Event generated by button press.
 */
void bsp_event_handler(bsp_event_t event) {
	//    ret_code_t err_code;

	switch (event) {
	case BSP_EVENT_SLEEP:
		sleep_mode_enter();
		break;

	default:
		break;
	}
}

/**@brief Function for initializing buttons and leds. */
static void buttons_leds_init(void) {
	ret_code_t err_code;
	bsp_event_t startup_event;

	err_code = bsp_init(BSP_INIT_LED, bsp_event_handler);
	APP_ERROR_CHECK(err_code);

	err_code = bsp_btn_ble_init(NULL, &startup_event);
	APP_ERROR_CHECK(err_code);
}

/**@brief Function for initializing the timer. */
static void timer_init(void) {
	ret_code_t err_code = app_timer_init();
	APP_ERROR_CHECK(err_code);
}

/**@brief Function for initializing the nrf log module. */
static void log_init(void) {
	ret_code_t err_code = NRF_LOG_INIT(NULL);
	APP_ERROR_CHECK(err_code);
}

/**@brief Function for initialiszeing the gpiote module. */
void gpio_init(void) {
	ret_code_t err_code = nrf_drv_gpiote_init();
	APP_ERROR_CHECK(err_code);
}

/**@brief Function for asserts in the SoftDevice.
 *
 * @details This function will be called in case of an assert in the SoftDevice.
 *
 * @warning This handler is an example only and does not fit a final product. You need to analyze
 *          how your product is supposed to react in case of Assert.
 * @warning On assert from the SoftDevice, the system can only recover on reset.
 *
 * @param[in] line_num     Line number of the failing ASSERT call.
 * @param[in] p_file_name  File name of the failing ASSERT call.
 */
void assert_nrf_callback(uint16_t line_num, const uint8_t * p_file_name) {
	NRF_LOG_ERROR("Line %d:", line_num);
	app_error_handler(0xDEADBEEF, line_num, p_file_name);
}

void scan_start(void) {
	ret_code_t ret;

	ret = sd_ble_gap_scan_start(&m_scan_params);
	APP_ERROR_CHECK(ret);

	ret = bsp_indication_set(BSP_INDICATE_SCANNING);
	APP_ERROR_CHECK(ret);
}

/**@brief Function for handling the Application's BLE Stack events.
 *
 * @param[in] p_ble_evt  Bluetooth stack event.
 */
void on_ble_evt(ble_evt_t * p_ble_evt) {
	const ble_gap_evt_t * p_gap_evt = &p_ble_evt->evt.gap_evt;

	switch (p_ble_evt->header.evt_id) {
	case BLE_GAP_EVT_ADV_REPORT: {
		const ble_gap_evt_adv_report_t * p_adv_report =
				&p_gap_evt->params.adv_report;

		if (p_adv_report->rssi > SCAN_THRESHOLD) { //TODO Whitelist
			NRF_LOG_DEBUG("Beacon %02x:%02x:%02x:%02x:%02x:%02x\r\n",
					p_adv_report->peer_addr.addr[5],
					p_adv_report->peer_addr.addr[4],
					p_adv_report->peer_addr.addr[3],
					p_adv_report->peer_addr.addr[2],
					p_adv_report->peer_addr.addr[1],
					p_adv_report->peer_addr.addr[0]);

			NRF_LOG_DEBUG("RSSI:%d Data:%d \r\n", p_adv_report->rssi,
					p_adv_report->dlen);

			NRF_LOG_HEXDUMP_DEBUG(p_adv_report->data, p_adv_report->dlen);
		}
	}
	break; // BLE_GAP_EVT_ADV_REPORT

	default:
		NRF_LOG_DEBUG("Defaulted Beacon Event %d:\r\n",
				p_ble_evt->header.evt_id);
		break;
	}
}

/**@brief Function for dispatching a BLE stack event to all modules with a BLE stack event handler.
 *
 * @details This function is called from the scheduler in the main loop after a BLE stack event has
 *          been received.
 *
 * @param[in] p_ble_evt  Bluetooth stack event.
 */
static void ble_evt_dispatch(ble_evt_t * p_ble_evt) {
	on_ble_evt(p_ble_evt);
	bsp_btn_ble_on_ble_evt(p_ble_evt);
}

void ble_stack_init(void) {
	ret_code_t err_code;

	nrf_clock_lf_cfg_t clock_lf_cfg = { .source = NRF_CLOCK_LF_SRC_XTAL,
			.rc_ctiv = 0, .rc_temp_ctiv = 0, .xtal_accuracy =
					NRF_CLOCK_LF_XTAL_ACCURACY_20_PPM };

	// Initialize the SoftDevice handler module.
	SOFTDEVICE_HANDLER_INIT(&clock_lf_cfg, NULL);

	// Fetch the start address of the application RAM.
	uint32_t ram_start = 0;
	err_code = softdevice_app_ram_start_get(&ram_start);
	APP_ERROR_CHECK(err_code);

	// Enable BLE stack.
	err_code = softdevice_enable(&ram_start);
	APP_ERROR_CHECK(err_code);

	// Register with the SoftDevice handler module for BLE events.
	err_code = softdevice_ble_evt_handler_set(ble_evt_dispatch);
	APP_ERROR_CHECK(err_code);
}


uint32_t request_next_event_earliest(void)
{
	m_slot_length_us                               = SLOT_LENGTH_US; //
	m_timeslot_request.request_type                = NRF_RADIO_REQ_TYPE_EARLIEST;
	m_timeslot_request.params.earliest.hfclk       = NRF_RADIO_HFCLK_CFG_XTAL_GUARANTEED;
	m_timeslot_request.params.earliest.priority    = NRF_RADIO_PRIORITY_NORMAL;
	m_timeslot_request.params.earliest.length_us   = m_slot_length_us;
	m_timeslot_request.params.earliest.timeout_us  = SLOT_TIMEOUT_US;
	return sd_radio_request(&m_timeslot_request);
}

/**@brief Configure next timeslot event in earliest configuration
 */
void configure_next_event_earliest(void)
{
	m_slot_length_us                               = SLOT_LENGTH_US; //100ms
	m_timeslot_request.request_type                = NRF_RADIO_REQ_TYPE_EARLIEST;
	m_timeslot_request.params.earliest.hfclk       = NRF_RADIO_HFCLK_CFG_XTAL_GUARANTEED;
	m_timeslot_request.params.earliest.priority    = NRF_RADIO_PRIORITY_NORMAL;
	m_timeslot_request.params.earliest.length_us   = m_slot_length_us;
	m_timeslot_request.params.earliest.timeout_us  = SLOT_TIMEOUT_US;
}

/**@brief Configure next timeslot event in normal configuration
 */
void configure_next_event_normal(void)
{
	m_slot_length_us                              = SLOT_LENGTH_US; //100ms
	m_timeslot_request.request_type               = NRF_RADIO_REQ_TYPE_NORMAL;
	m_timeslot_request.params.normal.hfclk        = NRF_RADIO_HFCLK_CFG_XTAL_GUARANTEED;
	m_timeslot_request.params.normal.priority     = NRF_RADIO_PRIORITY_HIGH;
	m_timeslot_request.params.normal.distance_us  = 100000;
	m_timeslot_request.params.normal.length_us    = SLOT_TIMEOUT_US;
}

void on_ir_pin(nrf_drv_gpiote_pin_t pin, nrf_gpiote_polarity_t action) {

	NRF_LOG_DEBUG("on_ir_pin\r\n");
	request_next_event_earliest();
	//APP_ERROR_CHECK(err_code);
}

void on_ts_start()
{
	nrf_gpio_pin_set(TIMESLOT_OUT);
}

void on_ts_stop()
{
	nrf_gpio_pin_clear(TIMESLOT_OUT);
}

void on_radio_cb()
{
	nrf_drv_gpiote_out_toggle(RADIO_OUT);
}

/**@brief Timeslot event handler
 */
nrf_radio_signal_callback_return_param_t * ts_radio_callback(uint8_t signal_type)
{
	//NRF_LOG_DEBUG("TS_RADIO_CB:%d\r\n", signal_type);
	switch(signal_type)
	{
	case NRF_RADIO_CALLBACK_SIGNAL_TYPE_START: {
		//Start of the timeslot - set up timer interrupt
		// Set up rescheduling
		NRF_TIMER0->INTENSET = (1UL << TIMER_INTENSET_COMPARE0_Pos);
		NRF_TIMER0->CC[0]    = m_slot_length_us - SLOT_SANITY_END_US;
		NVIC_EnableIRQ(TIMER0_IRQn);
		on_ts_start();
		signal_callback_return_param.params.request.p_next = NULL;
		signal_callback_return_param.callback_action = NRF_RADIO_SIGNAL_CALLBACK_ACTION_NONE;
	}
	break;

	case NRF_RADIO_CALLBACK_SIGNAL_TYPE_RADIO:
	{
		signal_callback_return_param.params.request.p_next = NULL;
		signal_callback_return_param.callback_action = NRF_RADIO_SIGNAL_CALLBACK_ACTION_NONE;
		on_radio_cb();
	}
	break;

	case NRF_RADIO_CALLBACK_SIGNAL_TYPE_TIMER0:{
		//Timer interrupt - attempt to increase timeslot length
		if (NRF_TIMER0->EVENTS_COMPARE[0] == 1)
		{
			NRF_TIMER0->EVENTS_COMPARE[0] = 0;

			signal_callback_return_param.params.extend.length_us = SLOT_EXTEND_US;
			signal_callback_return_param.callback_action         = NRF_RADIO_SIGNAL_CALLBACK_ACTION_EXTEND;
		}
	}
	break;

	case NRF_RADIO_CALLBACK_SIGNAL_TYPE_EXTEND_SUCCEEDED:
	{
		//Extension succeeded, reset timer(configurations still valid since slot length is the same)
		NRF_TIMER0->CC[0]    += SLOT_EXTEND_US;
	}
	break;

	case NRF_RADIO_CALLBACK_SIGNAL_TYPE_EXTEND_FAILED:
	{
		//Extension failed, schedule new timeslot at earliest time
		on_ts_stop();
		configure_next_event_earliest();
		signal_callback_return_param.params.request.p_next = &m_timeslot_request;
		signal_callback_return_param.callback_action = NRF_RADIO_SIGNAL_CALLBACK_ACTION_REQUEST_AND_END;
	}
	break;

	default:
		//No implementation needed
		break;
	}
	return (&signal_callback_return_param);
}

/**@brief Timeslot signal handler
 */
void nrf_evt_signal_handler(uint32_t evt_id)
{
	NRF_LOG_DEBUG("nrf_evt_signal_handler:%d\r\n", evt_id);
	uint32_t err_code;

	switch (evt_id)
	{
	case NRF_EVT_RADIO_SIGNAL_CALLBACK_INVALID_RETURN:
		//No implementation needed
		break;
	case NRF_EVT_RADIO_SESSION_IDLE:
		//No implementation needed
		break;
	case NRF_EVT_RADIO_SESSION_CLOSED:
		//No implementation needed, session ended
		break;
	case NRF_EVT_RADIO_BLOCKED: //Fall through
	case NRF_EVT_RADIO_CANCELED:
		err_code = request_next_event_earliest();
		APP_ERROR_CHECK(err_code);
		break;
	default:
		break;
	}
}

static void sys_evt_dispatch(uint32_t sys_evt)
{
	nrf_evt_signal_handler(sys_evt);
}


/**@brief Function for initializing the timeslot API.
 */
uint32_t timeslot_sd_init(void)
{
	uint32_t err_code;

	// Register with the SoftDevice handler module for BLE events.
	err_code = softdevice_sys_evt_handler_set(sys_evt_dispatch);
	NRF_LOG_DEBUG("softdevice_sys_evt_handler_set returns %d\r\n", err_code);
	APP_ERROR_CHECK(err_code);

	err_code = sd_radio_session_open(ts_radio_callback);
	NRF_LOG_DEBUG("sd_radio_session_open returns %d\r\n", err_code);
	if (err_code != NRF_SUCCESS)
	{
		return err_code;
	}

	err_code = request_next_event_earliest();
	NRF_LOG_DEBUG("request_next_event_earliest returns %d\r\n", err_code);
    if (err_code != NRF_SUCCESS)
    {
    	APP_ERROR_CHECK(err_code);
        (void)sd_radio_session_close();
        return err_code;
    }
	return NRF_SUCCESS;
}


void setup_ir_pin() {
	nrf_drv_gpiote_in_config_t in_config = {
			.sense = NRF_GPIOTE_POLARITY_HITOLO, .pull = NRF_GPIO_PIN_PULLUP,
			.is_watcher = false, .hi_accuracy = true };
	ret_code_t err_code = nrf_drv_gpiote_in_init(IR1_IN, &in_config,
			on_ir_pin);
	APP_ERROR_CHECK(err_code);
}

void enable_ir_pin() {
	nrf_drv_gpiote_in_event_enable(IR1_IN, true);
}

void disable_ir_pin() {
	nrf_drv_gpiote_in_event_disable(IR1_IN);
}

void setup_out_pin() {
	//TIMESLOT_OUT
	nrf_drv_gpiote_out_config_t out_config = {
			.action = NRF_GPIOTE_POLARITY_TOGGLE,
			.init_state = NRF_GPIOTE_INITIAL_VALUE_LOW,
			.task_pin = false
	};

	ret_code_t err_code = nrf_drv_gpiote_out_init(TIMESLOT_OUT, &out_config);
	APP_ERROR_CHECK(err_code);

	err_code = nrf_drv_gpiote_out_init(RADIO_OUT, &out_config);
	APP_ERROR_CHECK(err_code);

	err_code = nrf_drv_gpiote_out_init(RADIO_NOTIF_OUT, &out_config);
	APP_ERROR_CHECK(err_code);

	//nrf_drv_gpiote_out_toggle(_mPinNumber);
	//nrf_gpio_pin_clear(_mPinNumber);
	//nrf_gpio_pin_set(_mPinNumber);
}

/**@brief Function for initializing Radio Notification Software Interrupts.
 */
uint32_t radio_notification_init(uint32_t irq_priority, uint8_t notification_type, uint8_t notification_distance)
{
    uint32_t err_code;

    err_code = sd_nvic_ClearPendingIRQ(SWI1_IRQn);
    if (err_code != NRF_SUCCESS)
    {
        return err_code;
    }

    err_code = sd_nvic_SetPriority(SWI1_IRQn, irq_priority);
    if (err_code != NRF_SUCCESS)
    {
        return err_code;
    }

    err_code = sd_nvic_EnableIRQ(SWI1_IRQn);
    if (err_code != NRF_SUCCESS)
    {
        return err_code;
    }

    // Configure the event
    return sd_radio_notification_cfg_set(notification_type, notification_distance);
}

/**@brief Software interrupt 1 IRQ Handler, handles radio notification interrupts.
 */
void SWI1_IRQHandler(bool radio_evt)
{
    if (radio_evt)
    {
        nrf_gpio_pin_toggle(RADIO_NOTIF_OUT); //Toggle the status of the LED on each radio notification event
    }
}

/** @brief Function for the Power manager. */
static void power_manage(void) {
	ret_code_t err_code = sd_app_evt_wait();
	APP_ERROR_CHECK(err_code);
}

/** @brief main... */
int main(void) {
	log_init();
	NRF_LOG_DEBUG("log_init started.\r\n");

	timer_init();
	NRF_LOG_DEBUG("timer_init started.\r\n");

	gpio_init();
	NRF_LOG_DEBUG("gpio_init started.\r\n");

	setup_out_pin();

	/*
	uint8_t err_code = radio_notification_init(3, NRF_RADIO_NOTIFICATION_TYPE_INT_ON_ACTIVE, NRF_RADIO_NOTIFICATION_DISTANCE_800US);
	APP_ERROR_CHECK(err_code);
*/
	buttons_leds_init();
	NRF_LOG_DEBUG("buttons_leds_init started.\r\n");

	ble_stack_init();
	NRF_LOG_DEBUG("ble_stack_init started.\r\n");

	scan_start();
	NRF_LOG_DEBUG("scan_start started.\r\n");

	timeslot_sd_init();
	NRF_LOG_DEBUG("timeslot_sd_init started.\r\n");


	setup_ir_pin();
	enable_ir_pin();
	NRF_LOG_DEBUG("IR pin enabled.\r\n");

    
	NRF_LOG_INFO("BeaconScan started\r\n");

	for (;;) {
		power_manage();
	}
}
